---
resources:
    # multiple resources pointing to the same
    # repository are suffixed with the producer of new content

    - name: tpen-data-orig
      type: git
      source:
        uri: ((tpen-data-uri))
        branch: master
        private_key: ((DHOpsMU-priv-key))

    - name: tpen-data-tpen-backup
      type: git
      source:
        uri: ((tpen-data-uri))
        branch: master
        paths: [transcription]
        ignore_paths: [transcription/tei-xml]
        private_key: ((DHOpsMU-priv-key))

    - name: tpen-data-tpen2tei
      type: git
      source:
        uri: ((tpen-data-uri))
        branch: master
        paths: [transcription/tei-xml]
        private_key: ((DHOpsMU-priv-key))

    # This includes the tpen backup configuration, as well as the necessary
    # .netrc file for feeding stemmarest at the end.
    - name: repo-config
      type: git
      source:
        uri: ((repo-config-uri))
        paths: [((repo-config-path))]
        private_key: ((DHOpsMU-priv-key))

    - name: daily
      type: time
      source:
        start: 6:00 AM
        stop: 12:00 PM


jobs:

    - name: tpen-backup
      plan:
        - in_parallel:
          - get: daily
            trigger: true
          - get: tpen-data-orig
            params: {depth: 1}
          - get: repo-config

        - task: task-tpen-backup
          config:
            platform: linux
            image_resource: 
              type: registry-image
              source:
                repository: chrysaphi/edition-tools
            inputs:
              - name: tpen-data-orig
              - name: repo-config
            outputs:
              - name: do-backup
            run:
              path: sh
              args:
                - -exc
                - |
                  # NO IDEA why this is necessary, but otherwise the source
                  # repo is in detached-head state...
                  (cd tpen-data-orig && git checkout master)

                  git clone tpen-data-orig do-backup
                  # Put the relevant backup configuration into place
                  REPO=`echo ((tpen-data-uri)) | rev | cut -d / -f 1 | rev`
                  cp repo-config/${REPO}-ci/backup.yml /root/tpen/backup.yml
                  /root/tpen/backup.py do-backup
                  git config --global user.name "tools/tpen-backup"
                  git config --global user.email "ci@dh.gesch.univie.ac.at"
                  cd do-backup && git add transcription/*.json
                  GIT_STATUS=`git status`
                  if echo $GIT_STATUS | grep -q "Changes to be committed:" -;
                  then
                      git commit -m "T-PEN backup automagick"
                  fi

        - put: tpen-data-tpen-backup
          get_params: {depth: 1}
          params:
            repository: do-backup

    - name: json-tei-transform
      plan:
        - in_parallel:
          - get: tpen-data-tpen-backup
            params: {depth: 1}
            trigger: true
            passed: [tpen-backup]

        - task: task-tpen2tei
          config:
            platform: linux
            image_resource: 
              type: registry-image
              source:
                repository: chrysaphi/edition-tools
            inputs:
              - name: tpen-data-tpen-backup
            outputs:
              - name: tpen-data-bumped

            run:
              path: sh
              args:
                - -exc
                - |
                  (cd tpen-data-tpen-backup && git checkout master)
                  git clone tpen-data-tpen-backup tpen-data-bumped

                  cd tpen-data-bumped

                  ### use merged files
                  MERGE=((tpen-merge))
                  TRANSCRIPTION_DIR=transcription/
                  if [ "$MERGE" = "yes" ]; then
                    [ -d transcription/merged ] || mkdir transcription/merged/
                    python3 /root/scripts/merge-json.py transcription/ transcription/merged --verbose
                    if [ -f transcription/members.json ]; then
                      cp transcription/members.json transcription/merged
                    fi
                    TRANSCRIPTION_DIR=transcription/merged/
                  fi

                  ### create TEI-XML
                  JSON2XML_ARGS=
                  if [ -f transcription/config.py ]; then
                    JSON2XML_ARGS="-c transcription/config"
                  fi
                  [ -d transcription/tei-xml ] || mkdir transcription/tei-xml/
                  python3 /root/scripts/json2xml.py -v $TRANSCRIPTION_DIR transcription/tei-xml/ $JSON2XML_ARGS

                  git config --global user.email "ci@dh.gesch.univie.ac.at"
                  git config --global user.name "edition-tools/tpen2tei"

                  cd transcription/tei-xml/
                  git add *xml

                  GIT_STATUS=`git status`

                  if echo $GIT_STATUS | grep -q "Changes to be committed:" -;
                  then
                      git commit -m "tpen2tei" *xml
                  fi

        - put: tpen-data-tpen2tei
          get_params: {depth: 1}
          params: {repository: tpen-data-bumped}

    - name: validate-tei-xml
      plan:
        - get: tpen-data-tpen2tei
          params: {depth: 1}
          trigger: true
          passed: [json-tei-transform]

        - task: task-validate-tei-xml
          input_mapping: { tpen-data: tpen-data-tpen2tei }
          config:
            platform: linux
            image_resource: 
              type: registry-image
              source:
                repository: chrysaphi/edition-tools
            inputs:
              - name: tpen-data

            run:
              path: sh
              args:
                - -exc
                - |
                  SAVEIFS=$IFS
                  IFS=$(echo -n "\n\b")
                  # for now: don't care if a linter fails instead make sure
                  # all files are checked by swallowing the return value
                  #
                  sh -c '
                    ENFORCE=((enforce-validity))
                    verr=0
                    for FILE in tpen-data/transcription/tei-xml/*xml
                    do
                      echo === ${FILE##*/} ===
                      xmllint --noout --relaxng "((relaxng_schema))" "$FILE"
                      ret=$?
                      verr=$((verr + ret))
                    done
                    if [ $verr -ne 0 ]; then
                      echo "Some files failed to validate"
                    fi
                    if [ $ENFORCE = "yes" ]; then
                      exit $verr
                    fi
                    exit 0
                  '
                  IFS=$SAVEIFS

    - name: collate
      plan:
        - in_parallel:
          - get: tpen-data-tpen2tei
            params: {depth: 1}
            trigger: true
            passed: [validate-tei-xml]
          - get: repo-config

        - task: task-tokenize
          input_mapping: { repo-data: tpen-data-tpen2tei }
          config:
            image_resource: 
              type: registry-image
              source:
                repository: chrysaphi/edition-tools
            platform: linux
            inputs:
              - name: repo-data
            outputs:
              - name: tokenfiles

            run:
              path: sh
              args:
                - -exc
                - |
                  echo "tokenize readings for CollateX ..."
                  # Generate tokens for each milestone
                  python3 /root/scripts/teixml2collatex.py repo-data/transcription/tei-xml/ tokenfiles -c repo-data/transcription/config --verbose

        - task: task-collate-and-upload
          config:
            platform: linux
            image_resource: 
              type: registry-image
              source:
                repository: chrysaphi/edition-tools
            inputs:
              - name: tokenfiles
              - name: repo-config
            outputs:
              - name: collations

            run:
              path: sh
              args:
                - -exc
                - |
                  # PUT new user on test server
                  curl \
                      --silent \
                      --netrc-file repo-config/netrc/dot-netrc-editions.byzantini.st \
                      --netrc \
                      --request PUT \
                      --header "Content-Type: application/json" \
                      --data '{ "role":"((user-role))", "id":"((user-email))", "email":"((user-email))", "passphrase":"((user-passphrase))"}' \
                  ((api-test-base))/user/((user-email))
                  if [ $? -ne 0 ]; then
                      exit $?
                  fi

                  # Make the new empty tradition
                  curl \
                      --silent \
                      --netrc-file repo-config/netrc/dot-netrc-editions.byzantini.st \
                      --netrc \
                      --request POST \
                      --form "name=((tradition-name)) $(date "+%Y-%m-%d")" \
                      --form "language=((tradition-lang))" \
                      --form "public=no" \
                      --form "userId=((user-email))" \
                      --form "empty=no" \
                  ((api-test-base))/tradition > create-tradition.response
                  TRADITION_ID=`jq ".tradId" create-tradition.response | sed s/\"//g`
                  if [ -z $TRADITION_ID ]; then
                      exit 1
                  fi
                  export TRADITION_ID

                  SECTION_ID=''

                  # SAVEIFS=$IFS
                  # IFS=$(echo -en "\n\b")

                  # Go through each milestone, collate it, and upload it
                  echo "Collating and uploading milestones ..."
                  bash -c '
                      for IN_FILE in tokenfiles/milestone-*.json
                      do
                          NAME=${IN_FILE##*/}  # strip directory
                          NAME=${NAME%.*}      # strip file ext.

                          OUT_FILE_JSON=collations/$NAME.json
                          CMD_TIMEOUT="timeout 1000 "

                          # run the collation
                          CMD_COLLATE_JSON="java -jar /root/collatex.jar --tokenized --format json $IN_FILE --output $OUT_FILE_JSON"

                          echo `date -R`: $CMD_COLLATE_JSON
                          # $CMD_TIMEOUT $CMD_COLLATE_JSON
                          $CMD_COLLATE_JSON

                          # upload it to the server
                          SECTION_ID_PREV=${SECTION_ID}
                          SECTION_ID=''

                          CMD_CURL="curl --silent --netrc-file repo-config/netrc/dot-netrc-editions.byzantini.st --netrc --request POST"
                          CMD_CURL="${CMD_CURL} --form name=${NAME}"
                          CMD_CURL="${CMD_CURL} --form file=@${OUT_FILE_JSON}"
                          CMD_CURL="${CMD_CURL} --form filetype=cxjson"
                          CMD_CURL="${CMD_CURL} https://api.editions.byzantini.st/ChronicleMETest/stemmarest/tradition/${TRADITION_ID}/section"
                          echo $CMD_CURL

                          # Abort if we get five gateway errors in a row
                          SUCCESS=
                          for ((i=1; i < 6; i++)); do
                              echo -n "`date -R`: Attempt $i: "
                              $CMD_CURL > create-section.response
                              if grep -q "50.*Gateway" create-section.response
                              then
                                  echo Gateway error $i/3
                              else
                                  cat create-section.response; echo
                                  SUCCESS=true
                                  break
                              fi
                          done
                          if [ -z $SUCCESS ]
                          then
                              echo "Too many gateway errors in a row; bailing out"
                              exit 1
                          fi

                          SECTION_ID=`jq ".parentId" create-section.response | sed s/\"//g`
                      done
                  '
                  # IFS=$SAVEIFS
